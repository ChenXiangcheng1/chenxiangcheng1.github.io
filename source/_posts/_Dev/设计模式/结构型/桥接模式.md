---
title: 桥接模式
date: 2024-03-13
update: 2024-03-13
tag:
categories:
  - 设计模式
  - 结构型
keywords: 设计模式,桥接模式
description: 关于设计模式中的桥接模式
top_img:
cover: https://refactoringguru.cn/images/patterns/diagrams/bridge/structure-zh.png
---

# Bridge

## 意图

桥接模式是一种结构型设计模式，把实现独立出来，抽象部分与其实现部分分离，让抽象部分与实现部分可以各自独立地变化，这就使得每种实现的变化不会影响其他实现，抽象部分专注于处理高层逻辑， 实现部分处理平台细节。



## 结构

![img](https://refactoringguru.cn/images/patterns/diagrams/bridge/structure-zh.png)

1. **抽象部分**（Abstraction）提供高层控制逻辑，依赖于完成底层实际工作的实现对象。
2. **实现部分**（Implementation）为所有具体实现声明通用接口，聚合Implementor。 
   抽象部分仅能通过在这里声明的方法与实现对象交互。
   抽象部分可以列出和实现部分一样的方法，但是抽象部分通常声明一些复杂行为，这些行为依赖于多种由实现部分声明的原语操作。
3. **具体实现**（Concrete Implementations）中包括特定于抽象的代码。
4. **精确抽象**（Refined Abstraction）提供控制逻辑的变体。与其父类一样，它们通过通用实现接口与不同的实现进行交互。
5. 通常情况下，**客户端**（Client）仅关心如何与抽象部分合作。但是客户端需要将抽象对象与一个实现对象连接起来。



## 应用场景

* 如果你希望在几个独立维度上扩展/维护一个类，你可以使用桥接模式。

* 如果你需要在运行时切换不同实现方法，可使用桥接模式。
  实现：具体操作就是给成员变量赋新值
  (继承关系是在编译时就定义好的，所以无法在运行时改变从父类继承的实现)



## 实现方式

1. 在抽象类中添加指向实现类型的引用成员变量。抽象部分会将大部分工作委派给该成员变量所指向的实现对象。
2. 客户端代码必须将实现对象传递给抽象部分的构造函数才能使其能够相互关联



## 识别方法

存在桥接接口，抽象部分继承桥接接口，桥接接口依赖实现部分



## 我的评价

完美的



## 示例

遥控器有品牌和类型，两个维度的变化

```java
public abstract class TV {
    public abstract void turnOn();
    public abstract void turnOff();
}
```

```java
public class SamsungTV extends TV {
    @Override
    public void turnOn() {
        System.out.println("Samsung TV is turned on.");
    }

    @Override
    public void turnOff() {
        System.out.println("Samsung TV is turned off.");
    }
}

public class SonyTV extends TV {
    @Override
    public void turnOn() {
        System.out.println("Sony TV is turned on.");
    }

    @Override
    public void turnOff() {
        System.out.println("Sony TV is turned off.");
    }
}
```

```java
public abstract class RemoteControl {
    protected TV tv;

    public RemoteControl(TV tv) {
        this.tv = tv;
    }

    public abstract void powerOn();
    public abstract void powerOff();
}
```

```java
public class NormalRemoteControl extends RemoteControl {
    public NormalRemoteControl(TV tv) {
        super(tv);
    }

    @Override
    public void powerOn() {
        System.out.println("Normal remote control is powering on the TV.");
        tv.turnOn();
    }

    @Override
    public void powerOff() {
        System.out.println("Normal remote control is powering off the TV.");
        tv.turnOff();
    }
}

public class AdvancedRemoteControl extends RemoteControl {
    public AdvancedRemoteControl(TV tv) {
        super(tv);
    }

    @Override
    public void powerOn() {
        System.out.println("Advanced remote control is powering on the TV.");
        tv.turnOn();
    }

    @Override
    public void powerOff() {
        System.out.println("Advanced remote control is powering off the TV.");
        tv.turnOff();
    }
}
```

```java
public class Client {
    public static void main(String[] args) {
        TV samsungTV = new SamsungTV();
        TV sonyTV = new SonyTV();

        RemoteControl normalRemoteControlForSamsung = new NormalRemoteControl(samsungTV);
        RemoteControl advancedRemoteControlForSony = new AdvancedRemoteControl(sonyTV);

        normalRemoteControlForSamsung.powerOn();
        normalRemoteControlForSamsung.powerOff();

        advancedRemoteControlForSony.powerOn();
        advancedRemoteControlForSony.powerOff();
    }
}
```

