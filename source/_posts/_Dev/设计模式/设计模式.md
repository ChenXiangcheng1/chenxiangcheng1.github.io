---
title: 设计模式
date: 2023-7-13

categories:
  - 设计模式
keywords: 设计模式,面向对象编程
description: 总结了单例、简单工厂、建造者、外观、代理、适配器、装饰器、职责链、策略
top_img:
cover:
---

# OOP面向对象编程（Object Oriented Programming）

OOP是什么：针对抽象编程，即**程序中所有的依赖关系都是终止于抽象类或接口**，那就是面向对象的设计
优点：易维护、可复用、易扩展、灵活性好（组合使用）

静态绑定
  访问成员变量是静态绑定，调用的是调用的属性或方法
  判断调用者类型，判断被调用的类型，如果被调用的是成员变量，则启动静态绑定，将调用者的要调用的成员变量绑定过去（赋值）

动态绑定
  动态绑定是针对对象的方法，对属性无效，因为属性不能被重写

动态
  运行时

## 贫血模型和充血模型

* 面向过程的贫血模型：领域对象只有数据

* 面向对象的充血模型：领域对象包含业务

## UML类图

| 关系   |                        |
| ------ | ---------------------- |
| is-a   | 继承，是其中之一的种类 |
| can-do | 接口                   |
| has-a  | 组合，隶属于           |

**类：**

​  类图分为三部分，依次是类名、属性、方法；

​  以<<开头和以>>结尾的为注释信息；

​  修饰符**+代表public**，**-代表private**，**#代表protected**，**什么都没有 代表包可见**；

​  带**下划线**的属性或方法代表是**静态**的。

![](https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_15_19_08.gif)

**实现接口：**

![](https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_15_19_09.gif)

**类之间的耦合关系：类与出现在成员变量、方法的输入输出参数中的其他类的关系**
  A**组合关系**B
    强拥有关系，B是A的属性，B只能是以A对象的一部分存在，A是B和其他的组合

​  A**聚合关系**B
​    弱拥有关系，B是A的属性，B可以不以A对象的一部分存在，A是一群B的组合

​  A**关联关系**B
​    客户端就是关联别的类
​    一个类需要了解另外一个类，比依赖关系强烈，是一个类和另外一个类有关联
​  A**依赖关系**B
​    体现在方法上调用到另外一个
​    一个类需要依赖另外一个类，是一个类依赖另外一个类

<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_14_23_10.png" alt="image-20230514231013427" style="zoom:80%;" />

​ 别忘记还有耦合的数量关系哦

[UML类图入门介绍](https://blog.csdn.net/monkey_d_meng/article/details/6005764)

## OOP的设计原则SOLID

### SRP单一职责原则（Single Responsibility Principle）

**高内聚，低耦合**

就一个类而言，应该仅有一个引起它变化的原因，高内聚

如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏

客户端不需要知道高内聚的具体细节

比如计算器程序，运算部分和显示部分就是分开的，并且加减乘除都是独立的子类

### OCP开放封闭原则（The Open-Closed Principle）

**Open for extension、Closed for modification：对扩展开发，对修改关闭**

**要求软件实体（类、模块、函数等等）应该是可以扩展，但不可修改的**

比如计算器程序，实现加法功能，在需求改变时需要减法功能，就**创建抽象来隔离以后可能发生的同类变化**，不应该修改原有代码，如果不使用OCP，开发工作展开的越久，没隔离的类应用的越多，要创建正确的抽象就越困难

### LSP里氏代换原则（Liskov Substitution Principle）Liskov替换原则

**要求子类型必须能够替换掉它们的父类型**

即所有引用基类的地方必需能够满足引用子类对象，要求不改变父类的实现方法，继承抽象

由于里氏代换原则才使开放封闭原则的Open for extension成为可能

### ISP接口隔离原则（Interface Segregation Principle）

单一职责原则针对单个类的，接口隔离原则针对类之间的依赖耦合关系。接口隔离原则是指要将类间的依赖关系建立在最小的接口上，**在设计接口时应该尽量保证接口的单一性，即一个接口只负责一个功能或者行为**。这样可以让接口更加灵活、可复用，并且能够减少不必要的依赖关系，提高代码的可维护性和可扩展性。

在实践中，接口隔离原则的应用可以从以下几个方面考虑：

1. 避免设计“胖接口”：接口中的方法应该尽量少，并且只关注于一些相关的行为或功能，而不是所有可能的行为和功能。
2. 根据业务场景进行接口拆分：根据实际业务需求，将一个大接口拆分成多个小接口，并且让每个接口只关注于某个特定的行为或功能。
3. 遵循依赖倒置原则：依赖于抽象接口而不是具体实现，这样可以降低组件之间的耦合度，使得系统更加灵活可扩展。
4. 保持接口的稳定性：一旦一个接口被设计好，应该尽量避免频繁地修改它，以免影响到实现该接口的所有组件。

### DIP依赖倒转原则 控制反转（Inversion of Control ）

**要求高层模块不应该依赖底层模块，两个都应该依赖抽象，抽象不应该依赖细节，细节应该依赖抽象**

A需要调用B，那么A就是高层模块，B就是底层模块，这关系就是高层模块依赖底层模块，所以为了能够复用高层模块，高层模块不应该依赖底层模块，高层模块和底层模块都应该依赖抽象

通过依赖倒转原则，**把类与分支耦合的类抽象出一个接口，依赖关系通过接口实现**，变量声明尽量是接口或抽象类，所有重复的尽量上升到抽象类，并且两个类的关系不能依赖耦合，关系是通过接口实现的

如超市打折，对接口编程，需求变更不应该修改原有代码

### LoD迪米特法则（Law of Demeter）

也被叫做**LKP最少知识原则（Least Knowledge Principle）**

**如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。**如果如果其中一个类需要调用另一个类的某一个方法的话，可以**通过第三者转发这个调用**，**使得一个类对自己需要耦合或调用的类知道得最少**

两个不直接通信的类，通过接口转发调用。如，有事找IT部门再调用IT部门员工，而不是找IT部门的员工

降低类与类之间的耦合，形成弱耦合，类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。

结果就是产生了大量的中转或跳转类，导致系统的复杂性提高，增加了维护的难度。一个准则：只要跳转不超过两次都是可以忍受的，反之则要考虑重构。

# 设计模式

[一本设计模式好电子书](https://refactoringguru.cn/design-patterns/chain-of-responsibility)

​  通过面向对象六大原则，封装使程序易维护、可复用，通过继承、多态使程序可扩展、灵活性好，把程序的耦合度降低

​  设计模式核心：意图（什么情况下使用）；结构

设计模式的弊端引入许多子类！

设计模式就是UI

| 设计模式 | 作用 | 可实现 具体场景 |
| --- | --- | --- |
| 策略模式 | 单维度变化 | 通过组合(对象层级)允许运行时改变对象行为的策略 |
| 桥接模式 | 多维度变化 | 一般还会在桥接模式外套一层抽象接口模式(I工厂返回桥接_抽象，具体工厂返回桥接_实现) |
|  |  |  |
| 代理模式 | 给原始类添加功能 | 非核心需求(**访问控制**实现监控、统计、鉴权、限流、事务、日志、幂等(不重复执行)) |
| 简单工厂 | 创建对象(工厂方法代替构造函数 支持解耦(抽象产品)、其他来源(对象池、缓存)) | |
| 工厂方法 | 创建对象(继承 耦合转移) | |
| 模板方法 |  | 通过继承(类层级)允许子类静态地override特定步骤(**将某些步骤的实现延迟到子类**) |
| 抽象工厂 | 创建对象(抽象产品 减少工厂数量) | |
| 单例模式 | 提供全局唯一访问点，限制实例数量(集群唯一 进程唯一 线程唯一) | 全局共享(还可选全局变量、monostate模式)、处理资源访问冲突(选隔离范围) |
| monostate | 所有实例共享相同状态 | |
|  |  |  |
| 适配器模式 |  | 将一个接口转换为**统一接口**，适配器作为中间层屏蔽接口的不兼容性(封装兼容接口、统一多个类的接口设计、替换外部系统) |

创建型: 替代构造函数  
结构型: 替代目标类 Wrapper二次封装  
行为型: 替代目标方法  

## 设计模式分类

### 创建型

* #### 4.原型模式

### 结构型

#### 外观模式

* #### 6.外观模式（Facade Pattern）

  **意图：**外部与一个子系统的通信必须通过一个统一的门面(Facade)对象进行，门面模式为操作子系统中的一组接口提供一个高层次的接口，使得子系统更易于使用。

  ​  体现了依赖倒转原则和迪米特法则

  **使用场景：**

  ​  为一个复杂子系统提供一个简单接口。如，有一个设计粗糙的复杂的系统，可以设计Facade类，让新系统与Facade类対接，而Facade与遗留代码交互所有复杂的工作

  ​  提高子系统的独立性

  ​  在层次化结构中，可以使用Facade模式定义系统中每一层的入口。如，MVC的逻辑层、业务逻辑层和表示层的层与层之间建立外观Facade，这样可以为复杂的子系统提供简单的接口
  ​  

  **结构：**

  ![](https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_15_19_11.gif)

  在门面模式中，通常只需要一个**Facade门面类**，并且此门面类只有一个实例，换言之**它是一个单例类**。**对每一个子系统只有一个门面类**

  ![](https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_15_19_14.gif)

  门面模式效果：
  
  ![](https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_15_19_15.gif)
  
  平行关系开放的接口太多了

#### 装饰器模式(todo)

* #### 9.装饰器模式（Decorator）

**意图：**
  **动态地给一个对象添加一些额外的职责**，就增加功能来说，装饰模式比使用子类继承更加灵活
  建造者模式和装饰模式的区别：建造者模式的建造过程是稳定的，装饰模式是不稳定的

**应用场景：**

**结构：**

​

Component
 是定义的一个对象接口，可以给这些对象动态地添加职责

ConcreteComponent
 是定义的一个具体的对象，可以给这些添加一些职责

Decorator
 装饰抽象类，继承了Component，从外类来扩展Component类的功能，但对于Component来说，无需知道Decorator的存在。
 Decorator聚合Conponent
 我理解就是Decorator可以聚合ConcreteComponent和ConcreteDecorator，这样就可以实现一层一层有序聚合

ConcreteDecorator
 是具体的装饰对象，起到给Component添加职责的功能

*

* #### 10.组合模式

* #### 11.享元模式

* #### 12.桥梁模式

### 行为型

行为型设计模式关注对象之间的通信以及它们之间的职责分配。

#### 职责链模式

* #### 13.职责链模式（Chain of Responsibility）

  **意图**：该模式使更多的处理者对象 都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象(handler) 连成一条链，**并沿着这条链传递该请求，直到有一个对象处理它为止**。 有点像链表

  ​ 使用场景：

  ​  对于修改处理者 (handler) 的检查方法，检查代码本来就已经混乱不堪， 而每次新增功能都会使其更加臃肿。 修改某个检查步骤有时会影响其他的检查步骤。 最糟糕的是， 当你希望复用这些检查步骤来保护其他系统组件时， 你只能复制部分代码， 因为这些组件只需部分而非全部的检查步骤。

  **结构**：

  ​ `所有处理者类均实现同一接口`是关键所在。 每个具体处理者仅关心下一个包含 `execute`执行方法的处理者。 这样一来， 你就可以在运行时使用不同的处理者来创建链， 而无需将相关代码与处理者的具体类进行耦合。

![1610519123171](https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_15_19_17.png)

  实际应用：

![](https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_15_19_18.png)

应用程序的 GUI　通常为对象树结构。

![对象树的枝干可以组成一条链](https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_15_19_19.png)

JVM ClassLoader 的双亲委派机制也是职责链模式

* #### 15.命令模式

* #### 16.中介模式

* #### 17.模板方法模式

* #### 18.迭代器模式

* #### 19.访问者模式

* #### 21.解释器模式

* #### 22.备忘录模式

* #### 23.状态模式

# TODO

todo: prototype、template

# 未整理的笔记

1、SRP单一职责原则
 就一个类而言，应该仅有一个引起它变化的原因，高内聚
 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏

 客户端不需要知道细节

 比如计算器程序，运算部分和显示部分就是分开的，并且加减乘除都是独立的子类

3、LSP里氏代换原则  
 子类型必须能够替换掉它们的父类型  
 由于里氏代换原则才使开放封闭原则的Open for extension成为可能  
 所有引用基类的地方必需能够满足引用子类对象  
 要求不改变父类的实现方法，继承抽象  

===============================

 第一章 简单工厂模式
  为了实现松耦合，根据单一职责原则，我们往往面向抽象Product编程写出对应的Product子类，再通过简单工厂模式中方法中的switch语句create对应的Product实例
  若需要添加抽象Product，需要修改Factory类，不符合开放-封闭原则

​ 第三章 抽象工厂模式
​  抽象Factory里面应该包含所有的Product创建的抽象方法
​  ConcreteFactory Create具有特定实现的Product实例
​  若需要添加抽象Product，需要添加抽象Product、ConcreteProduct子类，修改抽象Factory、ConcreteFactory子类
​
​  工厂对应一种生产方法
​
​ 第四章 用简单工厂模式改进抽象工厂
​  用简单工厂代替抽象工厂，Factory类中通过不同方法区别产品，方法中通过swith区分方法。
​  若需要添加Product实现方法，就需要在Factory类中的多个方法中添加switch分支
​

 第五章 进阶
  通过Dependency Injection依赖注入 反射+抽象工厂解决switch分支
  就是通过switch的string来作为类名的一部分，作为要求（代价）类名必须要规范
class DataAccess
{
 private static readonly string db="Sqlserver";
 //private static readonly string db="Access";

 public static IUser CreateUser()
 {
  IUser result=null;
  switch(db)
  {
   case "Sqlserver":
    result =new SqlserverUser();
    break;
   case "Access":
    result =new AccessUser();
    break;
  }
  return result;
 }

 public static IDepartment CreateDepartment()
 ..........
}

using System.Reflection;
class DataAccess
{
 private static readonly string AssemblyName="抽象工厂模式";
 private static readonly string db="Sqlserver";

 public static IUser CreateUser()
 {
  string className=AssemblyName+"."+db+"User";
  return (IUser)Assembly.Load(AssemblyName).CreateInstance(className);
 }
 public static IDepartment CreateDepartment()
 ..........
}

  再利用配置文件解决更改Factory类的问题

================================
State状态模式
 当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类
 解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况，把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化

 Context类
  聚合State
  Request()方法维护一个ConcreteState子类的实例，这个实例定义当前的状态
 State抽象状态类
  定义一个接口以封装与Context的一个特定状态相关的行为
 ConcreteState具体状态
  具体状态，每一个子类实现一个与Context的一个状态相关的行为

 好处，通过定义新的子类可以很容易地增加新的状态和转换，消除庞大的条件分支语句，通过把各种状态转移逻辑分布到State的子类之间，来减少相互间的依赖，更易扩展

 State模式在一个对象的行为取决于它的状态，并且他必须在运行时刻根据状态改变他的行为时，就可以考虑使用

Memento备忘录模式
 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先的保存的状态

 Originator发起人
  依赖Memento，负责创建一个Memento备忘录，用以记录当时它的内部状态，并可使用备忘录恢复状态，Originator可根据需要决定Memento存储Originator的哪些内部状态
 Memento备忘录
  负责存储Originator对象的内部状态，并可防止Originator以外的其他对象访问Memento备忘录，Memento有两个接口，Caretaker只能看到Memento的窄接口，它只能将Memento传递给其他对象，Originator能够看到宽接口，允许他访问返回到先前状态所需的所有数据
 Caretaker管理者
  聚合Memento，负责保存好Memento，不能对Memento的内容进行操作或检查

Composite组合模式
 将对象组合成树形结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性

 Component
  组合中的对象声明接口，在适当情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component
 Leaf
  在组合中表示所有叶节点对象，叶节点没有子节点
 Composite
  聚合Component
  定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关的操作，比如增加Add和删除Remove

 透明方式
  在Component中声明所有用来管理子对象的方法Add和Remove，好处：叶节点和枝节点具备一致的行为接口对外界没有区别  坏处：但是Leaf中这接口没有意义
 安全方式
  在Component中不声明所有用来管理子对象的方法，坏处：客户端调用要做相应的判断

 使用情况：在需求中体现部分与整体层次结构，希望用户忽略组合对象与单个对象的不同，统一地使用组合结构中所有的对象

Iterator迭代器模式
 提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示

 Aggregate
  聚集抽象类
 Iterator
  迭代抽象类，用于定义得到开始对象、得到下一个对象、判断是否到结尾、当前对象等抽象方法，统一接口
 ConcreteAggregate
  具体聚集类
  依赖ConcreteIterator
 ConcreteIterator
  具体迭代器类，实现开始、下一个、是否结尾、当前对象等方法
  关联Concreteaggregate

 分离了集合对象的遍历行为，抽象出一个迭代器类来负责，可以不暴露集合的内部结构，又让外部代码透明地访问集合内部的数据

CARP合成/聚合复用原则
 Composition合成，Aggregation聚合
 尽量使用对象组合/聚合，而不是用继承来达到复用的目的，运行时进行动态绑定，类与类之间的耦合降低
 可以保持每个类被封装，并被集中在单个任务上，类的继承层次上会保持较小的规模，并且不太可能增长为不可控制的庞然大物

 继承一定要在是is-a关系时在考虑使用，而不是任何时候都去使用

Command命令模式
 将一个请求封装成为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销操作

 Invoker
  要求该命令执行这个请求
  知道要执行的操作
 Command
  用来声明执行操作的接口  
 Receiver
  知道如何实施与执行一个请求相关的操作，任何类都可能作为一个接受者
  Recriver知道所有操作
 ConcreteCommand
  将一个接受者对象绑定于一个动作，调用接收者来执行相应的操作，以实现Execute
  依赖Receiver，调用Receiver来执行相应操作

 紧耦合
  为一个类添加多个方法，客户端调用这个类
  直接调用Receiver来执行
 松耦合
  命令模式

 优点：
  命令模式把请求一个操作的对象与指导怎么执行一个操作的对象分割开
  比较容易设置命令队列
  容易把命令记录日志
  允许接收请求的一方决定是否要否决请求
  容易实现对请求的撤销和重做
  加入新的具体的命令类不影响其他的类

Mediator中介模式、调停者模式
 用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地互相引用，从而使其耦合松散，而且可以独立地改变它们之间的交互

 Mediator
  抽象中介者，定义了同事对象到中介者对象的接口
 Colleague
  抽象同事对象
  聚合Mediator
   执行方法通过Mediator执行
 ConcreteMediator
  具体中介者对象，实现抽象类的方法，它需要知道所有具体同事类，并从具体同事接受消息，向具体同事对象发出命令
  关联ConcreteColleague，给ConcreteColleague留属性位置，给ConcreteColleague的方法留方法位置
 ConcreteColleague
  具体同事类，每个具体同事只知道自己的行为，而不了解其他同事类的情况，但它们却都认识中介者对象

 优点：ConcreteMediator减少了各个ConcreteColleague的耦合，可以独立更改oncreteColleague，可以在Mediator中调用每个类，而不是一个类调用类外一个类的完成

 缺点：但是ConcreteMediator就职责过多了，它要关联很多ConcreteCoolleague

 平时的Main class就是一个Mediator

Flyweight享元模式
 运用共享技术有效地支持大量细粒度的对象

 FlyweightFactory
  一个享元工厂，用来创建并管理Flyweight对象。它主要是用来确保合理地共享Flyweight，当用户请求一个Flyweight时，FlyweightFactory对象创建一个已创建的实例或者创建一个（如果不存在的话）
  关联ConcreteFlyweight
  有一个返回ConcreteFlyweight的方法
 Flyweight
  所有具体享元类的超类或接口，通过这个接口，Flyweight可以接受并作用于外部状态
 ConcreteFlyweight
  继承Flyweight超类或实现Flyweight接口，并为内部状态增加存储空间
 UnsharedConcreteFlyweight
  指那些不需要共享的Flyweight子类。因为Flyweight接口共享成为可能，但它并不强制共享

 内部状态存储于ConcreteFlyweight
 外部状态，在调用Flyweight对象时，将该状态传递给它
  可以只实例化外部状态，复用内部状态

 单例模式和享元模式的区别
  单例模式
   主要是判断自己是否实例化过（全局只能由一个ConcreteFlyweight）
  享元模式
   调用的时候返回同一个，可以用单例模式来实现享元模式
   可以用单例模式来实现，返回的是同一个对象
   可以先实例化在工厂中，每次返回同一个对象
   也可以在工厂中使用类似单例模式的形式（但不是单例模式，因为还可以newConcreteFlyweight）
  单例模式是要实现只能有一个，享元模式是要实现复用同一个

 string就应用了享元模式

Interpreter解释器模式
 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子

 根据依赖倒转原则，抽象出一个抽象类，作为AbstractExpression来实现客户端和算法子类的解耦

 Context
  包含解释器之外的一些全局信息
 AbstractExpression
  抽象表达式，声明一个抽象的Interpret（Context）解释操作，这个接口为抽象语法树中所有的节点所共享
  定义解释的方法
 TerminalExpression
  终结符表达式，实现与文法中的终结符相关联的解释操作
  定义对应文法的方法
 NonterminalExpression
  非终结符表达式，为文法中的非终结表达符实现解释操作。对文法中每一条规则R1...Rn都需要一个具体的非终结符表达式类

 如正则表达式判断字符串格式，浏览器解释html

 当有一个语言需要解释执行，并且你可以将该语言中的句子表示为一个抽象语法树时，可使用解释器模式
 容易地改变和扩展文法，因为该模式使用类来表示文法规则，你可使用继承来改变或扩展该文法。也比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体类似，这些类都易于直接编写

 但是，解释器为文法中每一条规则至少定义了一个类，因此包含许多规则的文法可能难以管理和维护。建议当文法非常复杂时，使用其他的技术如语法分析程序或编译器生成器来处理

 增加一个文法时，除了扩展一个类外，还改动了客户端。就是在switch语句选择实例化的问题，可以用简单工厂加放射解决

Visitor访问者模式
 表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作

 Visitor
  为该对象结构中ConcreteElement的每一个类对象声明一个Visit操作，方法VisitConcreteElement（ConcreteElement）
  状态
 ObjectStructure
  能枚举它的元素，可以提供一个高层的接口以允许访问者访问它的元素
  关联Element
 ConcreteVisitor
  具体访问者，实现每个由Visitor声明的操作，每个操作实现算法的一部分，而该算法片段乃是对应于结构中对象的类
 Element
  定义一个Accept操作，它以一个访问者为参数，Accept（Visitor）
 ConcreteElement
  具体元素，实现Accept操作

 双分派技术
 在客户端中将ConcreteElement作为参数传递给ConcreteVisitor的方法作为第一次分派，然后该方法调用ConcreteElement中的方法把this作为参数传递进去，这是第二次分派
 双分派意味着得到执行的操作决定与请求的种类和两个接受者的类型。接受方法就是一个双分派的操作

 访问者模式要求ConcreteElement相对稳定，增加ConcreteVisitor只需要增加实现Visitor接口

 访问者模式适合用于数据结构相对稳定的系统，他把数据结构和作用域结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化

## 模式组合

命令模式 (Command) + 备忘录模式 (Memento):
命令: 将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化。
备忘录: 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后能恢复。命令对象可以使用备忘录来保存执行操作前的状态，以支持撤销 (Undo) 操作。

装饰器避免继承结构爆炸而设计
